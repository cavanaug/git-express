#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e
# Treat unset variables as an error when substituting.
set -u
# Pipelines return the exit status of the last command that failed, or zero if all succeed.
set -o pipefail

# --- Usage ---
usage() {
    echo "Usage: git-express <command> [<args>]"
    echo ""
    echo "Commands:"
    echo "  clone <repository> [<directory>]   Clone a repository and set up worktrees"
    # Add other commands here later
    exit 1
}

# --- Clone command ---
cmd_clone() {
    local repository=""
    local directory=""
    local branch_to_checkout=""
    local clone_options=() # Options to pass to git clone

    # --- Argument Parsing ---
    # Simplified parsing: Identify -b, repository, directory. Pass others to git clone.
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -b)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: Option -b requires a branch name." >&2
                    usage
                fi
                branch_to_checkout="$2"
                shift 2 # Consume -b and its argument
                ;;
            --)
                # End of options marker. Add remaining args to clone_options.
                shift # Consume --
                clone_options+=("$@")
                break # Stop parsing
                ;;
            -*)
                # It's an option for git clone. Add it and its potential argument.
                clone_options+=("$1")
                shift # Consume the option flag
                # Check if the next argument is NOT an option itself (doesn't start with -)
                # and is not empty. If so, assume it's the value for the current option.
                if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                    clone_options+=("$1")
                    shift # Consume the option's value
                fi
                ;;
            *)
                # Positional arguments: first is repo, second is directory
                if [ -z "$repository" ]; then
                    repository="$1"
                elif [ -z "$directory" ]; then
                    directory="$1"
                else
                    # Unexpected positional argument. Pass it to git clone.
                    echo "Warning: Unexpected positional argument '$1'. Passing to git clone." >&2
                    clone_options+=("$1")
                fi
                shift # Consume the positional argument
                ;;
        esac
    done

    # --- Validation ---
    if [ -z "$repository" ]; then
        echo "Error: Missing repository argument for clone command." >&2
        usage
    fi

    # Derive default directory name if not provided
    if [ -z "$directory" ]; then
        directory=$(basename "$repository" .git)
    fi

    # --- Execution ---
    echo "Cloning repository '$repository' into '$directory'..."
    # Note: We don't pass -b to git clone here. We handle the branch checkout later.
    git clone "${clone_options[@]}" "$repository" "$directory"

    # Navigate into the cloned repository (dynamic worktree)
    pushd "$directory" > /dev/null

    local branch_for_static_worktree=""
    if [ -n "$branch_to_checkout" ]; then
        # User specified a branch with -b
        branch_for_static_worktree="$branch_to_checkout"
        echo "Setting up worktree for specified branch '$branch_for_static_worktree'..."
        # Check if the branch exists locally or remotely
        if ! git show-ref --verify --quiet "refs/heads/$branch_for_static_worktree" && \
           ! git show-ref --verify --quiet "refs/remotes/origin/$branch_for_static_worktree"; then
             echo "Error: Branch '$branch_for_static_worktree' not found locally or in origin remote." >&2
             # Clean up potentially incomplete clone? Maybe not, let user decide.
             popd > /dev/null
             return 1 # Use return instead of exit for functions
        fi
    else
        # Determine the default branch name (handle main/master variations)
        echo "Determining default branch..."
        branch_for_static_worktree=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
        if [ -z "$branch_for_static_worktree" ]; then
            echo "Error: Could not determine the default branch." >&2
            popd > /dev/null
            return 1
        fi
        echo "Setting up worktree for default branch '$branch_for_static_worktree'..."
    fi

    # Flatten the branch name (replace / with -)
    local flattened_branch_name
    flattened_branch_name=$(echo "$branch_for_static_worktree" | sed 's/[^a-zA-Z0-9._-]/-/g') # More robust flattening

    # Construct the worktree directory name relative to the parent directory
    local worktree_dir="../${directory}.${flattened_branch_name}"

    echo "Creating static worktree at '$worktree_dir' for branch '$branch_for_static_worktree'..."
    # Use --force because the branch might already exist in the main worktree checkout (especially the default branch)
    # Or if -b specified a branch that's the same as the default HEAD checkout.
    # We also need to ensure the branch exists for `git worktree add`.
    # If the branch is remote, `git worktree add` can check it out directly.
    if git worktree add --force "$worktree_dir" "$branch_for_static_worktree"; then
        echo "Static worktree created successfully."
    else
        echo "Error: Failed to create worktree for branch '$branch_for_static_worktree'." >&2
        # Attempt to clean up? Maybe just report error.
        popd > /dev/null
        return 1
    fi


    # Return to the original directory
    popd > /dev/null

    echo "Git-express clone complete for '$directory'."
    echo "Dynamic view: $directory"
    echo "Static worktree for $branch_for_static_worktree: $worktree_dir"
}

# --- Main script logic ---
main() {
    if [ $# -eq 0 ]; then
        usage
    fi

    local command="$1"
    shift # Remove the command name from the arguments list

    case "$command" in
        clone)
            cmd_clone "$@"
            ;;
        --help|-h)
            usage
            ;;
        # Add other command cases here
        *)
            echo "Error: Unknown command '$command'"
            usage
            ;;
    esac
}

# Execute main function with all script arguments
main "$@"

