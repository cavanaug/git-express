#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e
# Treat unset variables as an error when substituting.
set -u
# Pipelines return the exit status of the last command that failed, or zero if all succeed.
set -o pipefail

# --- Usage ---
usage() {
    echo "Usage: git-express <command> [<args>]"
    echo ""
    echo "Commands:"
    echo "  clone <repository> [<directory>]   Clone a repository and set up worktrees"
    # Add other commands here later
    exit 1
}

# --- Clone command ---
cmd_clone() {
    local repository=""
    local directory=""
    local branch_to_checkout=""
    local clone_options=() # Options to pass to git clone

    # --- Argument Parsing ---
    # Simplified parsing: Identify -b, repository, directory. Pass others to git clone.
    while [[ $# -gt 0 ]]; do
        case "$1" in
        -b)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: Option -b requires a branch name." >&2
                usage
            fi
            branch_to_checkout="$2"
            shift 2 # Consume -b and its argument
            ;;
        -q|--quiet)
            quiet_mode=true
            clone_options+=("$1") # Pass -q to git clone as well
            shift # Consume -q or --quiet
            ;;
        --)
            # End of options marker. Add remaining args to clone_options.
            shift # Consume --
            clone_options+=("$@")
            break # Stop parsing
            ;;
        -*)
            # It's an option for git clone. Add it and its potential argument.
            clone_options+=("$1")
            shift # Consume the option flag
            # Check if the next argument is NOT an option itself (doesn't start with -)
            # and is not empty. If so, assume it's the value for the current option.
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                clone_options+=("$1")
                shift # Consume the option's value
            fi
            ;;
        *)
            # Positional arguments: first is repo, second is directory
            if [ -z "$repository" ]; then
                repository="$1"
            elif [ -z "$directory" ]; then
                directory="$1"
            else
                # Unexpected positional argument. Pass it to git clone.
                echo "Warning: Unexpected positional argument '$1'. Passing to git clone." >&2
                clone_options+=("$1")
            fi
            shift # Consume the positional argument
            ;;
        esac
    done

    # --- Validation ---
    if [ -z "$repository" ]; then
        echo "Error: Missing repository argument for clone command." >&2
        usage
    fi

    # Derive default directory name if not provided
    if [ -z "$directory" ]; then
        directory=$(basename "$repository" .git)
    fi

    # --- Execution ---
    if [ "$quiet_mode" = false ]; then
        echo "Cloning repository '$repository' into '$directory'..."
    fi
    # Note: We don't pass -b to git clone here. We handle the branch checkout later.
    # Pass collected options (including -q if present) to git clone
    git clone "${clone_options[@]}" "$repository" "$directory"

    # Navigate into the cloned repository (dynamic worktree)
    pushd "$directory" >/dev/null

    local branch_for_static_worktree=""
    if [ -n "$branch_to_checkout" ]; then
        # User specified a branch with -b
        branch_for_static_worktree="$branch_to_checkout"
        if [ "$quiet_mode" = false ]; then
            echo "Setting up worktree for specified branch '$branch_for_static_worktree'..."
        fi
        # Check if the branch exists locally or remotely
        # Use git rev-parse for potentially better scripting interface than show-ref
        if ! git rev-parse --verify --quiet "refs/heads/$branch_for_static_worktree" > /dev/null 2>&1 && \
           ! git rev-parse --verify --quiet "refs/remotes/origin/$branch_for_static_worktree" > /dev/null 2>&1; then
            echo "Error: Branch '$branch_for_static_worktree' not found locally or in origin remote." >&2
            # Clean up potentially incomplete clone? Maybe not, let user decide.
            popd >/dev/null
            return 1 # Use return instead of exit for functions
        fi
    else
        # Determine the default branch name (handle main/master variations)
        if [ "$quiet_mode" = false ]; then
            echo "Determining default branch..."
        fi
        # Use git symbolic-ref --short for cleaner output if available, fallback otherwise
        branch_for_static_worktree=$(git symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null || git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
        if [ -z "$branch_for_static_worktree" ]; then
            echo "Error: Could not determine the default branch." >&2
            popd >/dev/null
            return 1
        fi
        if [ "$quiet_mode" = false ]; then
            echo "Setting up worktree for default branch '$branch_for_static_worktree'..."
        fi
    fi

    # Flatten the branch name (replace / with -)
    local flattened_branch_name
    flattened_branch_name=$(echo "$branch_for_static_worktree" | sed 's/[^a-zA-Z0-9._-]/-/g') # More robust flattening

    # Construct the worktree directory name relative to the parent directory
    local worktree_dir="../${directory}.${flattened_branch_name}"

    if [ "$quiet_mode" = false ]; then
        echo "Creating static worktree at '$worktree_dir' for branch '$branch_for_static_worktree'..."
    fi
    # Use --force because the branch might already exist in the main worktree checkout (especially the default branch)
    # Or if -b specified a branch that's the same as the default HEAD checkout.
    # We also need to ensure the branch exists for `git worktree add`.
    # If the branch is remote, `git worktree add` can check it out directly.
    # Add --quiet to worktree add if quiet_mode is true
    local worktree_add_opts=("--force")
    if [ "$quiet_mode" = true ]; then
        worktree_add_opts+=("--quiet")
    fi

    if git worktree add "${worktree_add_opts[@]}" "$worktree_dir" "$branch_for_static_worktree"; then
        if [ "$quiet_mode" = false ]; then
            echo "Static worktree created successfully."
        fi
    else
        echo "Error: Failed to create worktree for branch '$branch_for_static_worktree'." >&2
        # Attempt to clean up? Maybe just report error.
        popd >/dev/null
        return 1
    fi

    # Return to the original directory
    popd >/dev/null

    if [ "$quiet_mode" = false ]; then
        echo
        echo "git-express clone complete for '$directory'."
        # Extract the worktree directory name from the path
        local worktree_name
        worktree_name=$(basename "$worktree_dir")
        echo "git-express worktree complete for $worktree_name"
    fi
}

# --- Main script logic ---
main() {
    if [ $# -eq 0 ]; then
        usage
    fi

    local command="$1"
    shift # Remove the command name from the arguments list

    case "$command" in
    clone)
        cmd_clone "$@"
        ;;
    --help | -h)
        usage
        ;;
    # Add other command cases here
    *)
        echo "Error: Unknown command '$command'"
        usage
        ;;
    esac
}

# Execute main function with all script arguments
main "$@"
