#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e
# Treat unset variables as an error when substituting.
set -u
# Pipelines return the exit status of the last command that failed, or zero if all succeed.
set -o pipefail

# --- Usage ---
usage() {
    echo "Usage: git-express <command> [<args>]"
    echo ""
    echo "Commands:"
    echo "  clone <repository> [<directory>]   Clone a repository and set up worktrees"
    # Add other commands here later
    exit 1
}

# --- Clone command ---
cmd_clone() {
    if [ $# -lt 1 ]; then
        echo "Error: Missing repository argument for clone command."
        usage
    fi

    local repository="$1"
    shift # Remove repository from arguments

    # All remaining arguments are passed directly to git clone
    local clone_args=("$@")

    # Derive default directory name from repository URL
    local directory
    directory=$(basename "$repository" .git)

    # Check if the last argument is intended as the directory
    # Check if clone_args is not empty first
    if [ ${#clone_args[@]} -gt 0 ]; then
        local last_arg="${clone_args[${#clone_args[@]}-1]}" # Get the last argument safely

        # Check if the last argument is not an option (doesn't start with '-')
        # and is not the same as the repository URL (unlikely after shift, but safe)
        # and is not part of options after '--'
        if [[ ! " ${clone_args[@]} " =~ " -- " ]] && [[ "$last_arg" != "$repository" ]] && [[ ! "$last_arg" =~ ^- ]]; then
            # Assume last arg is the directory name
            directory="$last_arg"
            # Remove the directory from clone_args
            unset 'clone_args[${#clone_args[@]}-1]'
        fi
    fi

    echo "Cloning repository '$repository' into '$directory'..."
    # Pass remaining clone_args (if any)
    git clone "$repository" "${clone_args[@]}" "$directory"

    # Navigate into the cloned repository
    pushd "$directory" > /dev/null

    echo "Setting up worktree for default branch..."
    # Determine the default branch name (handle main/master variations)
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')

    if [ -z "$default_branch" ]; then
        echo "Error: Could not determine the default branch."
        popd > /dev/null
        exit 1
    fi

    # Flatten the branch name (replace / with -)
    local flattened_branch_name
    flattened_branch_name=$(echo "$default_branch" | sed 's/\//-/g')

    # Construct the worktree directory name relative to the parent directory
    local worktree_dir="../${directory}.${flattened_branch_name}"

    echo "Creating worktree at '$worktree_dir' for branch '$default_branch'..."
    # Use --force because the branch already exists in the main worktree checkout
    git worktree add --force "$worktree_dir" "$default_branch"

    # Return to the original directory
    popd > /dev/null

    echo "Git-express clone complete for '$directory'."
    echo "Dynamic view: $directory"
    echo "Static worktree for $default_branch: $worktree_dir"
}

# --- Main script logic ---
main() {
    if [ $# -eq 0 ]; then
        usage
    fi

    local command="$1"
    shift # Remove the command name from the arguments list

    case "$command" in
        clone)
            cmd_clone "$@"
            ;;
        # Add other command cases here
        *)
            echo "Error: Unknown command '$command'"
            usage
            ;;
    esac
}

# Execute main function with all script arguments
main "$@"

