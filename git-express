#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e
# Treat unset variables as an error when substituting.
set -u
# Pipelines return the exit status of the last command that failed, or zero if all succeed.
set -o pipefail

# --- Usage Functions ---
usage_clone() {
    echo "Usage: git-express clone [opts] [-b <branch>] <repo> [<dir>]"
    echo ""
    echo "  Clone a repository and set up worktrees."
    echo "  Creates a dynamic worktree in <dir> (derived from <repo> if not specified)."
    echo "  Creates a static worktree for the specified or default branch."
    echo ""
    echo "  Options:"
    echo "    -b <branch>   Branch to create the initial static worktree for (defaults to repo HEAD)."
    echo "    -q, --quiet   Suppress informational messages from git-express and underlying git commands."
    echo "    [opts]        Other options are passed directly to 'git clone'."
    exit 0 # Exit successfully after showing help
}

usage_add() {
    echo "Usage: git-express add [opts] <branch>"
    echo ""
    echo "  Create a static worktree for <branch>."
    echo "  If <branch> does not exist, it is created based on the current HEAD."
    echo "  Worktree is created at ../<repo_name>.<flattened_branch_name>."
    echo ""
    echo "  Options:"
    echo "    -q, --quiet   Suppress informational messages from git-express and underlying git commands."
    echo "    [opts]        Other options are passed directly to 'git worktree add'."
    exit 0
}

usage_list() {
    echo "Usage: git-express list"
    echo ""
    echo "  List all worktrees associated with the current repository."
    echo "  Marks the current worktree with '*'."
    echo "  Marks the dynamic worktree with '(dynamic)'."
    echo "  Output format: [* ]<branch> [(dynamic)] <path>"
    exit 0
}

usage_remove() {
    echo "Usage: git-express remove [opts] <branch-name | worktree-path>"
    echo ""
    echo "  Remove an existing static git-express worktree, specified by branch name or path."
    echo "  Uses 'git worktree remove' internally."
    echo "  Example (by path): git-express remove ../my-repo.feature-x"
    echo "  Example (by branch): git-express remove feature-x"
    echo ""
    echo "  Options:"
    echo "    -f, --force   Force removal even if the worktree has uncommitted changes."
    echo "    -q, --quiet   Suppress informational messages from git-express and underlying git commands."
    echo "    [opts]        Other options are passed directly to 'git worktree remove'."
    # Exit 0 when called for help, rely on calling function's exit status for errors
    return 0
}

# Main usage function (called for general errors or top-level help)
usage() {
    echo "Usage: git-express <command> [<args>]"
    echo "       git-express <command> --help"
    echo ""
    echo "Commands:"
    echo "  clone [opts] [-b <branch>] <repo> [<dir>]  Clone repo and setup worktrees"
    echo "  add   [opts] <branch>                   Create worktree for <branch>, create branch if needed"
    echo "  list                                    List all git-express managed worktrees"
    echo "  remove [opts] <worktree-path>            Remove a static worktree"
    # Add other commands here later
    exit 1
}

# --- Clone command ---
cmd_clone() {
    # Check for help option first (use default expansion to avoid unbound variable error)
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        usage_clone
    fi

    local repository=""
    local directory=""
    local branch_to_checkout=""
    local clone_options=() # Options to pass to git clone
    local quiet_mode=false # Flag for quiet operation

    # --- Argument Parsing ---
    # Simplified parsing: Identify -b, -q, repository, directory. Pass others to git clone.
    while [[ $# -gt 0 ]]; do
        case "$1" in
        -b)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: Option -b requires a branch name." >&2
                usage
            fi
            branch_to_checkout="$2"
            shift 2 # Consume -b and its argument
            ;;
        -q|--quiet)
            quiet_mode=true
            clone_options+=("$1") # Pass -q to git clone as well
            shift # Consume -q or --quiet
            ;;
        --)
            # End of options marker. Add remaining args to clone_options.
            shift # Consume --
            clone_options+=("$@")
            break # Stop parsing
            ;;
        -*)
            # It's an option for git clone. Add it and its potential argument.
            clone_options+=("$1")
            shift # Consume the option flag
            # Check if the next argument is NOT an option itself (doesn't start with -)
            # and is not empty. If so, assume it's the value for the current option.
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                clone_options+=("$1")
                shift # Consume the option's value
            fi
            ;;
        *)
            # Positional arguments: first is repo, second is directory
            if [ -z "$repository" ]; then
                repository="$1"
            elif [ -z "$directory" ]; then
                directory="$1"
            else
                # Unexpected positional argument. Pass it to git clone.
                echo "Warning: Unexpected positional argument '$1'. Passing to git clone." >&2
                clone_options+=("$1")
            fi
            shift # Consume the positional argument
            ;;
        esac
    done

    # --- Validation ---
    if [ -z "$repository" ]; then
        echo "Error: Missing repository argument for clone command." >&2
        usage
    fi

    # Derive default directory name if not provided
    if [ -z "$directory" ]; then
        directory=$(basename "$repository" .git)
    fi

    # --- Execution ---
    if [ "$quiet_mode" = false ]; then
        echo "Cloning repository '$repository' into '$directory'..."
    fi
    # Note: We don't pass -b to git clone here. We handle the branch checkout later.
    # Pass collected options (including -q if present) to git clone
    git clone "${clone_options[@]}" "$repository" "$directory"

    # Navigate into the cloned repository (dynamic worktree)
    pushd "$directory" >/dev/null

    local branch_for_static_worktree=""
    if [ -n "$branch_to_checkout" ]; then
        # User specified a branch with -b
        branch_for_static_worktree="$branch_to_checkout"
        if [ "$quiet_mode" = false ]; then
            echo "Setting up worktree for specified branch '$branch_for_static_worktree'..."
        fi
        # Check if the branch exists locally or remotely
        # Use git rev-parse for potentially better scripting interface than show-ref
        if ! git rev-parse --verify --quiet "refs/heads/$branch_for_static_worktree" > /dev/null 2>&1 && \
           ! git rev-parse --verify --quiet "refs/remotes/origin/$branch_for_static_worktree" > /dev/null 2>&1; then
            echo "Error: Branch '$branch_for_static_worktree' not found locally or in origin remote." >&2
            # Clean up potentially incomplete clone? Maybe not, let user decide.
            popd >/dev/null
            return 1 # Use return instead of exit for functions
        fi
    else
        # Determine the default branch name by checking the current branch in the main worktree
        if [ "$quiet_mode" = false ]; then
            echo "Determining default branch (from current checkout)..."
        fi
        # We are already inside the main worktree (due to pushd)
        branch_for_static_worktree=$(git branch --show-current)
        if [ -z "$branch_for_static_worktree" ]; then
             # Fallback or error handling if HEAD is detached after clone (unlikely but possible)
             echo "Warning: Could not determine branch name using 'git branch --show-current'. Trying symbolic-ref..." >&2
             # symbolic-ref HEAD might give the full ref name, use --short if available
             branch_for_static_worktree=$(git symbolic-ref --short HEAD 2>/dev/null)
             if [ -z "$branch_for_static_worktree" ]; then
                 # Final fallback: try parsing the remote HEAD again, ensuring prefix removal
                 echo "Warning: Could not determine branch name using 'git symbolic-ref --short HEAD'. Trying remote HEAD..." >&2
                 branch_for_static_worktree=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@' 2>/dev/null)
                 if [ -z "$branch_for_static_worktree" ]; then
                     echo "Error: Could not determine the default branch name." >&2
                     popd >/dev/null
                     return 1
                 fi
             fi
        fi
        if [ "$quiet_mode" = false ]; then
            echo "Setting up worktree for default branch '$branch_for_static_worktree'..."
        fi
    fi

    # Flatten the branch name (replace / with -)
    local flattened_branch_name
    flattened_branch_name=$(echo "$branch_for_static_worktree" | sed 's/[^a-zA-Z0-9._-]/-/g') # More robust flattening

    # Construct the worktree directory name relative to the parent directory
    local worktree_dir="../${directory}.${flattened_branch_name}"

    if [ "$quiet_mode" = false ]; then
        echo "Creating static worktree at '$worktree_dir' for branch '$branch_for_static_worktree'..."
    fi
    # Use --force because the branch might already exist in the main worktree checkout (especially the default branch)
    # Or if -b specified a branch that's the same as the default HEAD checkout.
    # We also need to ensure the branch exists for `git worktree add`.
    # If the branch is remote, `git worktree add` can check it out directly.
    # Add --quiet to worktree add if quiet_mode is true
    local worktree_add_opts=("--force")
    if [ "$quiet_mode" = true ]; then
        worktree_add_opts+=("--quiet")
    fi

    if git worktree add "${worktree_add_opts[@]}" "$worktree_dir" "$branch_for_static_worktree"; then
        if [ "$quiet_mode" = false ]; then
            echo "Static worktree created successfully."
        fi
    else
        echo "Error: Failed to create worktree for branch '$branch_for_static_worktree'." >&2
        # Attempt to clean up? Maybe just report error.
        popd >/dev/null
        return 1
    fi

    # Return to the original directory
    popd >/dev/null

    if [ "$quiet_mode" = false ]; then
        echo
        echo "git-express clone complete for '$directory'."
        # Extract the worktree directory name from the path
        local worktree_name
        worktree_name=$(basename "$worktree_dir")
        echo "git-express worktree complete for $worktree_name"
    fi
}


# --- Add command ---
cmd_add() {
    # Check for help option first (use default expansion to avoid unbound variable error)
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        usage_add
    fi

    local branch_name=""
    local worktree_options=() # Options to pass to git worktree add
    local quiet_mode=false    # Flag for quiet operation (though less output in 'new' anyway)

    # --- Argument Parsing ---
    # Parse options first, then expect the branch name
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quiet)
                quiet_mode=true
                worktree_options+=("$1") # Pass -q to git worktree add
                shift # Consume -q or --quiet
                ;;
            --)
                # End of options marker. Remaining args should contain the branch name.
                shift # Consume --
                break # Stop parsing options
                ;;
            -*)
                # Assume it's another option for git worktree add
                worktree_options+=("$1")
                shift # Consume the option flag
                # Check if the next argument is NOT an option itself
                if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                    worktree_options+=("$1")
                    shift # Consume the option's value
                fi
                ;;
            *)
                # First non-option argument is the branch name
                if [ -z "$branch_name" ]; then
                    branch_name="$1"
                    shift # Consume the branch name
                else
                    # Unexpected positional argument after branch name
                    echo "Error: Unexpected argument '$1' after branch name '$branch_name'." >&2
                    usage
                fi
                ;;
        esac
    done

    # --- Validation ---
    # Check if branch name was provided
    if [ -z "$branch_name" ]; then
        echo "Error: Missing branch name for 'add' command." >&2
        usage
    fi

    # Check if inside a git repository/worktree
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "Error: Not inside a git repository or worktree." >&2
        return 1
    fi

    # Get main worktree path (top-level directory of the repo)
    local main_worktree_path
    main_worktree_path=$(git rev-parse --show-toplevel)
    if [ -z "$main_worktree_path" ]; then
        echo "Error: Could not determine the repository's top-level directory." >&2
        return 1
    fi
    local repo_name
    repo_name=$(basename "$main_worktree_path")

    # Flatten the branch name
    local flattened_branch_name
    flattened_branch_name=$(echo "$branch_name" | sed 's/[^a-zA-Z0-9._-]/-/g') # Use the same robust flattening as clone

    # Construct the expected static worktree directory path (relative to parent of main worktree)
    local worktree_dir="../${repo_name}.${flattened_branch_name}"

    # Check if the target worktree directory already exists
    if [ -e "$worktree_dir" ]; then # Use -e to check for file or directory
        echo "Error: Target worktree directory '$worktree_dir' already exists." >&2
        return 1
    fi

    # --- Execution ---
    local branch_exists=false
    # Check if branch exists locally or remotely
    if git rev-parse --verify --quiet "refs/heads/$branch_name" > /dev/null 2>&1 || \
       git rev-parse --verify --quiet "refs/remotes/origin/$branch_name" > /dev/null 2>&1; then
        branch_exists=true
    fi

    if [ "$quiet_mode" = false ]; then
        echo "Creating worktree for branch '$branch_name' at '$worktree_dir'..."
    fi

    # Determine options for git worktree add
    # User-provided options were already collected into worktree_options
    local add_cmd_options=("${worktree_options[@]}")

    if $branch_exists; then
        # Branch exists, just create worktree pointing to it
        # Use --force? Maybe not by default for 'new'. Let user pass it via options.
        if git worktree add "${add_cmd_options[@]}" "$worktree_dir" "$branch_name"; then
            if [ "$quiet_mode" = false ]; then
                echo "Worktree created for existing branch '$branch_name'."
            fi
        else
            echo "Error: Failed to create worktree for existing branch '$branch_name'." >&2
            # git worktree add might have created the dir but failed, attempt cleanup
            rmdir "$worktree_dir" 2>/dev/null || true
            return 1
        fi
    else
        # Branch does not exist, create it using -b
        # The new branch will be based on the current HEAD
        if [ "$quiet_mode" = false ]; then
            echo "Branch '$branch_name' does not exist. Creating new branch and worktree..."
        fi
        # Add -b to the command options specifically for this case
        if git worktree add -b "$branch_name" "${add_cmd_options[@]}" "$worktree_dir"; then
             if [ "$quiet_mode" = false ]; then
                 echo "New branch '$branch_name' and worktree created."
             fi
             # Optional: Push the new branch? Maybe not by default.
             # git -C "$worktree_dir" push --set-upstream origin "$branch_name"
        else
            echo "Error: Failed to create new branch '$branch_name' and worktree." >&2
            # git worktree add might have created the dir but failed, attempt cleanup
            rmdir "$worktree_dir" 2>/dev/null || true
            # Also attempt to clean up the potentially created branch if add failed midway
            git branch -D "$branch_name" 2>/dev/null || true
            return 1
        fi
    fi

    if [ "$quiet_mode" = false ]; then
        echo "git-express add complete for $repo_name.$flattened_branch_name"
    fi
}


# --- Remove command ---
cmd_remove() {
    # Check for help option first and exit cleanly
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        usage_remove # This function now exits 0 when called for help
        exit 0 # Explicitly exit 0 after showing help
    fi

    local target_identifier="" # Can be branch name or path
    local remove_options=() # Options to pass to git worktree remove
    local quiet_mode=false
    local force_mode=false # Specific flag for --force

    # --- Argument Parsing ---
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quiet)
                quiet_mode=true
                remove_options+=("$1") # Pass -q to git worktree remove
                shift
                ;;
            -f|--force)
                force_mode=true
                remove_options+=("$1") # Pass -f to git worktree remove
                shift
                ;;
            --)
                shift # Consume --
                break # Stop parsing options
                ;;
            -*)
                # Assume it's another option for git worktree remove
                remove_options+=("$1")
                shift
                # Check if the next argument is NOT an option itself
                if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                    remove_options+=("$1")
                    shift
                fi
                ;;
            *)
                # Positional argument: the branch name or worktree path
                if [ -z "$target_identifier" ]; then
                    target_identifier="$1"
                else
                    echo "Error: Unexpected argument '$1' for 'remove' command. Target already set to '$target_identifier'." >&2
                    usage_remove # Show specific usage for remove
                fi
                shift
                ;;
        esac
    done

    # --- Validation ---
    if [ -z "$target_identifier" ]; then
        echo "Error: Missing required <branch-name | worktree-path> argument for 'remove' command." >&2
        usage_remove
    fi

    # Check if inside a git repository/worktree
    # Run this check *before* resolving paths relative to the main worktree
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "Error: Not inside a git repository or worktree." >&2
        return 1
    fi

    # Get main worktree path (dynamic view)
    local main_worktree_path
    main_worktree_path=$(git rev-parse --show-toplevel)
     if [ -z "$main_worktree_path" ]; then
        echo "Error: Could not determine the repository's top-level directory." >&2
        return 1
    fi
    local abs_main_worktree_path
    abs_main_worktree_path=$(realpath "$main_worktree_path")
    local main_worktree_parent_dir
    main_worktree_parent_dir=$(dirname "$main_worktree_path")
    local repo_name=$(basename "$main_worktree_path")

    # --- Identify Target Worktree Path ---
    # Determine if the identifier is likely a path or a branch name
    # Heuristic: contains '/' or '.' -> likely a path. Otherwise, likely a branch name.
    local identified_path=""
    local is_branch_input=false

    if [[ "$target_identifier" == *"/"* || "$target_identifier" == *"."* ]]; then
        # Treat as path
        is_branch_input=false
        identified_path="$target_identifier"
        if [ "$quiet_mode" = false ]; then
            echo "Interpreting '$target_identifier' as a path." >&2 # Info message to stderr
        fi
    else
        # Treat as branch name
        is_branch_input=true
        local target_branch="$target_identifier"
        if [ "$quiet_mode" = false ]; then
            echo "Interpreting '$target_identifier' as a branch name." >&2 # Info message to stderr
        fi
        # Construct the expected static worktree path based on convention
        local flattened_branch_name
        flattened_branch_name=$(echo "$target_branch" | sed 's/[^a-zA-Z0-9._-]/-/g')
        identified_path="../${repo_name}.${flattened_branch_name}"
    fi

    # Resolve the identified path using realpath -m to get a canonical path
    local abs_identified_path
    abs_identified_path=$(realpath -m "$identified_path")
     if [ -z "$abs_identified_path" ]; then
        echo "Error: Could not resolve canonical path for target '$identified_path'." >&2
        return 1
    fi
    local identified_path_exists=false
    if [ -e "$identified_path" ]; then
        identified_path_exists=true
    fi

    # Prevent removing the main (dynamic) worktree by resolved path
    if [ "$abs_identified_path" == "$abs_main_worktree_path" ]; then
            echo "Error: Cannot remove the main (dynamic) worktree ('$target_identifier')." >&2
            echo "git-express only supports removing static worktrees." >&2
            return 1
    fi
    # Removed extra 'fi' here

    # --- Verify Registration and Handle Stale ---
    local found_registration=false
    local git_registered_path="" # Path string as listed by git worktree list
    local git_registered_branch="" # Branch name as listed by git worktree list

    while IFS= read -r line; do
        # Extract path and branch from porcelain output
        local current_path="" branch=""
        if [[ "$line" == worktree* ]]; then
            current_path=$(echo "$line" | cut -d' ' -f2-)
        elif [[ "$line" == branch* ]]; then
            branch=$(echo "$line" | cut -d' ' -f2-)
            branch=$(basename "$branch") # Clean ref name
        elif [[ "$line" == "" && -n "$current_path" ]]; then
            # End of a block, resolve and compare
            local abs_current_registered_path
            if [[ "$current_path" == /* ]]; then
                abs_current_registered_path=$(realpath -m "$current_path")
            else
                abs_current_registered_path=$(realpath -m "$main_worktree_parent_dir/$current_path")
            fi

            if [ -z "$abs_current_registered_path" ]; then
                 echo "Warning: Could not resolve canonical path for registered worktree '$current_path'. Skipping." >&2
                 current_path="" # Reset for next block
                 branch=""
                 continue
            fi

            # Compare resolved paths
            if [ "$abs_current_registered_path" == "$abs_identified_path" ]; then
                found_registration=true
                git_registered_path="$current_path"
                git_registered_branch="$branch"
                break # Found our match
            fi
            # Reset for next block
            current_path=""
            branch=""
        fi
    done < <(git worktree list --porcelain --porcelain) # Need --porcelain twice for branch info

    # --- Post-Loop Validation ---
    if [ "$found_registration" = false ]; then
        if [ "$identified_path_exists" = true ]; then
             # Path exists but isn't registered
             echo "Error: Path '$identified_path' exists but is not a registered git worktree for this repository." >&2
        elif [ "$is_branch_input" = true ]; then
             # Input was branch name, but no matching worktree found
             echo "Error: No registered worktree found for branch '$target_identifier'." >&2
        else
             # Input was path, path doesn't exist, and wasn't registered
             echo "Error: Worktree path '$identified_path' does not exist and is not a registered worktree." >&2
        fi
        return 1
    fi

    # Check for stale entry (registration found, but path doesn't exist)
    if [ "$identified_path_exists" = false ]; then
        echo "Error: Worktree path '$identified_path' (derived from '$target_identifier') does not exist, but a registration was found." >&2
        echo "Use 'git-express prune' (not yet implemented) to remove stale worktree entries." >&2
        return 1
    fi

    # If we reach here, we have a valid, existing, registered worktree to remove.

    # Use the path known by git for the remove command.
    # Use the originally identified path (before realpath) for display messages.
    local target_path_for_git_cmd="$git_registered_path"
    local worktree_basename
    worktree_basename=$(basename "$target_path_for_git_cmd") # Basename from git's path
    local display_path="$identified_path" # Path for user messages


    # --- Execution ---
    # Stale entry case is now handled above and causes an error exit.
    # Proceed only if the path exists and is a registered worktree.

    if [ "$quiet_mode" = false ]; then
        if [ "$force_mode" = true ]; then
            echo "Force removing worktree '$display_path'..."
        else
            echo "Removing worktree '$display_path'..."
        fi
    fi

    # Prepare options for git worktree remove. DO NOT pass --quiet.
    local remove_cmd_options=()
    # Copy only known/safe options from user input (currently just -f/--force)
    # Or simply pass all non -q options through? Let's pass them through for now,
    # but filter out -q/--quiet explicitly.
    for opt in "${remove_options[@]}"; do
        if [[ "$opt" != "-q" && "$opt" != "--quiet" ]]; then
            remove_cmd_options+=("$opt")
        fi
    done

    # Ensure --force is present if force_mode is true and not already passed by user
    if [ "$force_mode" = true ] && ! printf '%s\n' "${remove_cmd_options[@]}" | grep -q -e '-f' -e '--force'; then
         remove_cmd_options+=("--force")
    fi


    # Execute git worktree remove
    # Pass the path exactly as git knows it
    if git worktree remove "${remove_cmd_options[@]}" "$target_path_for_git_cmd"; then
        if [ "$quiet_mode" = false ]; then
            echo "Worktree removed successfully."
            # Use basename for the final confirmation message
            echo "git-express remove complete for $worktree_basename"
        fi
    else
        # Use the display path in the error message
        echo "Error: Failed to remove worktree '$display_path'." >&2
        # git worktree remove might fail if there are uncommitted changes (without --force)
        # or other issues.
        return 1
    fi
}


# --- List command ---
cmd_list() {
    # Check for help option first
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        usage_list
    fi

    # Check if inside a git repository/worktree
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "Error: Not inside a git repository or worktree." >&2
        return 1
    fi

    # Get the absolute path of the current worktree's top-level directory
    local current_worktree_path
    current_worktree_path=$(git rev-parse --show-toplevel)
    if [ -z "$current_worktree_path" ]; then
        echo "Error: Could not determine the current worktree path." >&2
        return 1
    fi

    # Get the main worktree path (where .git directory resides or points to)
    # For regular repos, this is the same as toplevel. For worktrees, it's different.
    # We need the *original* repo path to identify the dynamic view.
    # Let's assume the dynamic view is the one listed by `git worktree list`
    # that doesn't have a separate .git file but contains the main .git dir.
    # A simpler heuristic for git-express: the dynamic view is the one whose
    # basename matches the repo name derived from the static worktree names.
    # Or, more reliably: parse `git worktree list --porcelain`.

    local main_worktree_path="" # Path of the main/dynamic worktree
    local worktree_data=()      # Array to hold parsed data {path, branch, is_current, is_dynamic}

    # Use porcelain format for stable parsing
    local current_path=""
    local current_branch=""
    local is_dynamic=true # Flag to track if we are processing the first (dynamic) entry

    while IFS= read -r line; do
        if [[ "$line" == worktree* ]]; then
            # Start of a linked worktree entry. The *next* entry processed will be static.
            # Note: This line itself provides the path for the linked worktree.
            current_path=$(echo "$line" | cut -d' ' -f2-)
            # We don't set is_dynamic=false here yet, but when we *store* this entry later.
        elif [[ "$line" == path* ]]; then
            # Path for the main worktree (only occurs once at the beginning)
            if $is_dynamic; then # Only capture path if we expect the main worktree
                 current_path=$(echo "$line" | cut -d' ' -f2-)
            # else: ignore path lines within linked worktree blocks if they exist (unlikely)
            fi
        elif [[ "$line" == HEAD* ]]; then
            : # Ignore HEAD commit line
        elif [[ "$line" == branch* ]]; then
            current_branch=$(echo "$line" | cut -d' ' -f2-)
            # Clean up ref name (e.g., refs/heads/main -> main)
            current_branch=$(basename "$current_branch")
        elif [[ "$line" == "" && -n "$current_path" ]]; then
            # End of a block, store the collected data

            local is_current=false
            if [ "$current_path" == "$current_worktree_path" ]; then
                is_current=true
            fi

            # Store data: path|branch|is_current|is_dynamic
            # The value of is_dynamic correctly reflects the block we just finished processing.
            worktree_data+=("${current_path}|${current_branch}|${is_current}|${is_dynamic}")

            # Reset for the next block
            current_path=""
            current_branch=""
            # IMPORTANT: After processing the first block (the dynamic one),
            # set is_dynamic to false for all subsequent blocks.
            is_dynamic=false
        fi
    done < <(git worktree list --porcelain)

    # Process the very last entry if the input didn't end with a blank line (unlikely for porcelain)
     if [[ -n "$current_path" ]]; then
        local is_current=false
        if [ "$current_path" == "$current_worktree_path" ]; then
            is_current=true
        fi
        # The is_dynamic flag will have the correct value from the loop state
        worktree_data+=("${current_path}|${current_branch}|${is_current}|${is_dynamic}")
     fi

    # --- Format Output ---
    local OLD_IFS="$IFS"
    IFS='|'
    for entry in "${worktree_data[@]}"; do
        # Split the entry string back into variables
        local path branch is_current is_dynamic
        read -r path branch is_current is_dynamic <<< "$entry"

        local prefix="  "
        local display_branch="$branch"

        if [ "$is_current" = true ]; then
            prefix="* "
        fi

        if [ "$is_dynamic" = true ]; then
            # Append (dynamic) to the branch name for display
            display_branch="${branch} (dynamic)"
        fi

        # Use printf for consistent spacing. Adjust width as needed.
        # The width should accommodate the longest possible branch name + " (dynamic)".
        # Let's increase it slightly, e.g., to 30.
        printf "%s%-30s %s\n" "$prefix" "$display_branch" "$path"

    done
    IFS="$OLD_IFS" # Restore original IFS
}


# --- Main script logic ---
main() {
    if [ $# -eq 0 ]; then
        usage
    fi

    local command="$1"
    shift # Remove the command name from the arguments list

    case "$command" in
    clone)
        cmd_clone "$@"
        ;;
    add)
        cmd_add "$@"
        ;;
    list)
        cmd_list "$@"
        ;;
    remove)
        cmd_remove "$@"
        ;;
    --help | -h)
        usage
        ;;
    # Add other command cases here
    *)
        echo "Error: Unknown command '$command'"
        usage
        ;;
    esac
}

# Execute main function with all script arguments
main "$@"
