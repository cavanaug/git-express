#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
set -e
# Treat unset variables as an error when substituting.
set -u
# Pipelines return the exit status of the last command that failed, or zero if all succeed.
set -o pipefail

# --- Usage ---
usage() {
    echo "Usage: git-express <command> [<args>]"
    echo ""
    echo "Commands:"
    echo "  clone [opts] [-b <branch>] <repo> [<dir>]  Clone repo and setup worktrees"
    echo "  new   [opts] <branch>                   Create worktree for <branch>, create branch if needed"
    # Add other commands here later
    exit 1
}

# --- Clone command ---
cmd_clone() {
    local repository=""
    local directory=""
    local branch_to_checkout=""
    local clone_options=() # Options to pass to git clone
    local quiet_mode=false # Flag for quiet operation

    # --- Argument Parsing ---
    # Simplified parsing: Identify -b, -q, repository, directory. Pass others to git clone.
    while [[ $# -gt 0 ]]; do
        case "$1" in
        -b)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: Option -b requires a branch name." >&2
                usage
            fi
            branch_to_checkout="$2"
            shift 2 # Consume -b and its argument
            ;;
        -q|--quiet)
            quiet_mode=true
            clone_options+=("$1") # Pass -q to git clone as well
            shift # Consume -q or --quiet
            ;;
        --)
            # End of options marker. Add remaining args to clone_options.
            shift # Consume --
            clone_options+=("$@")
            break # Stop parsing
            ;;
        -*)
            # It's an option for git clone. Add it and its potential argument.
            clone_options+=("$1")
            shift # Consume the option flag
            # Check if the next argument is NOT an option itself (doesn't start with -)
            # and is not empty. If so, assume it's the value for the current option.
            if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                clone_options+=("$1")
                shift # Consume the option's value
            fi
            ;;
        *)
            # Positional arguments: first is repo, second is directory
            if [ -z "$repository" ]; then
                repository="$1"
            elif [ -z "$directory" ]; then
                directory="$1"
            else
                # Unexpected positional argument. Pass it to git clone.
                echo "Warning: Unexpected positional argument '$1'. Passing to git clone." >&2
                clone_options+=("$1")
            fi
            shift # Consume the positional argument
            ;;
        esac
    done

    # --- Validation ---
    if [ -z "$repository" ]; then
        echo "Error: Missing repository argument for clone command." >&2
        usage
    fi

    # Derive default directory name if not provided
    if [ -z "$directory" ]; then
        directory=$(basename "$repository" .git)
    fi

    # --- Execution ---
    if [ "$quiet_mode" = false ]; then
        echo "Cloning repository '$repository' into '$directory'..."
    fi
    # Note: We don't pass -b to git clone here. We handle the branch checkout later.
    # Pass collected options (including -q if present) to git clone
    git clone "${clone_options[@]}" "$repository" "$directory"

    # Navigate into the cloned repository (dynamic worktree)
    pushd "$directory" >/dev/null

    local branch_for_static_worktree=""
    if [ -n "$branch_to_checkout" ]; then
        # User specified a branch with -b
        branch_for_static_worktree="$branch_to_checkout"
        if [ "$quiet_mode" = false ]; then
            echo "Setting up worktree for specified branch '$branch_for_static_worktree'..."
        fi
        # Check if the branch exists locally or remotely
        # Use git rev-parse for potentially better scripting interface than show-ref
        if ! git rev-parse --verify --quiet "refs/heads/$branch_for_static_worktree" > /dev/null 2>&1 && \
           ! git rev-parse --verify --quiet "refs/remotes/origin/$branch_for_static_worktree" > /dev/null 2>&1; then
            echo "Error: Branch '$branch_for_static_worktree' not found locally or in origin remote." >&2
            # Clean up potentially incomplete clone? Maybe not, let user decide.
            popd >/dev/null
            return 1 # Use return instead of exit for functions
        fi
    else
        # Determine the default branch name by checking the current branch in the main worktree
        if [ "$quiet_mode" = false ]; then
            echo "Determining default branch (from current checkout)..."
        fi
        # We are already inside the main worktree (due to pushd)
        branch_for_static_worktree=$(git branch --show-current)
        if [ -z "$branch_for_static_worktree" ]; then
             # Fallback or error handling if HEAD is detached after clone (unlikely but possible)
             echo "Warning: Could not determine branch name using 'git branch --show-current'. Trying symbolic-ref..." >&2
             # symbolic-ref HEAD might give the full ref name, use --short if available
             branch_for_static_worktree=$(git symbolic-ref --short HEAD 2>/dev/null)
             if [ -z "$branch_for_static_worktree" ]; then
                 # Final fallback: try parsing the remote HEAD again, ensuring prefix removal
                 echo "Warning: Could not determine branch name using 'git symbolic-ref --short HEAD'. Trying remote HEAD..." >&2
                 branch_for_static_worktree=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@' 2>/dev/null)
                 if [ -z "$branch_for_static_worktree" ]; then
                     echo "Error: Could not determine the default branch name." >&2
                     popd >/dev/null
                     return 1
                 fi
             fi
        fi
        if [ "$quiet_mode" = false ]; then
            echo "Setting up worktree for default branch '$branch_for_static_worktree'..."
        fi
    fi

    # Flatten the branch name (replace / with -)
    local flattened_branch_name
    flattened_branch_name=$(echo "$branch_for_static_worktree" | sed 's/[^a-zA-Z0-9._-]/-/g') # More robust flattening

    # Construct the worktree directory name relative to the parent directory
    local worktree_dir="../${directory}.${flattened_branch_name}"

    if [ "$quiet_mode" = false ]; then
        echo "Creating static worktree at '$worktree_dir' for branch '$branch_for_static_worktree'..."
    fi
    # Use --force because the branch might already exist in the main worktree checkout (especially the default branch)
    # Or if -b specified a branch that's the same as the default HEAD checkout.
    # We also need to ensure the branch exists for `git worktree add`.
    # If the branch is remote, `git worktree add` can check it out directly.
    # Add --quiet to worktree add if quiet_mode is true
    local worktree_add_opts=("--force")
    if [ "$quiet_mode" = true ]; then
        worktree_add_opts+=("--quiet")
    fi

    if git worktree add "${worktree_add_opts[@]}" "$worktree_dir" "$branch_for_static_worktree"; then
        if [ "$quiet_mode" = false ]; then
            echo "Static worktree created successfully."
        fi
    else
        echo "Error: Failed to create worktree for branch '$branch_for_static_worktree'." >&2
        # Attempt to clean up? Maybe just report error.
        popd >/dev/null
        return 1
    fi

    # Return to the original directory
    popd >/dev/null

    if [ "$quiet_mode" = false ]; then
        echo
        echo "git-express clone complete for '$directory'."
        # Extract the worktree directory name from the path
        local worktree_name
        worktree_name=$(basename "$worktree_dir")
        echo "git-express worktree complete for $worktree_name"
    fi
}


# --- New command ---
cmd_new() {
    local branch_name=""
    local worktree_options=() # Options to pass to git worktree add

    # --- Argument Parsing ---
    # Simple parsing: first arg is branch, rest are options for worktree add
    if [ $# -eq 0 ]; then
        echo "Error: Missing branch name for 'new' command." >&2
        usage # Or provide more specific usage for 'new'
    fi
    branch_name="$1"
    shift
    worktree_options=("$@") # Capture remaining arguments

    # --- Validation ---
    # Check if inside a git repository/worktree
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "Error: Not inside a git repository or worktree." >&2
        return 1
    fi

    # Get main worktree path (top-level directory of the repo)
    local main_worktree_path
    main_worktree_path=$(git rev-parse --show-toplevel)
    if [ -z "$main_worktree_path" ]; then
        echo "Error: Could not determine the repository's top-level directory." >&2
        return 1
    fi
    local repo_name
    repo_name=$(basename "$main_worktree_path")

    # Flatten the branch name
    local flattened_branch_name
    flattened_branch_name=$(echo "$branch_name" | sed 's/[^a-zA-Z0-9._-]/-/g') # Use the same robust flattening as clone

    # Construct the expected static worktree directory path (relative to parent of main worktree)
    local worktree_dir="../${repo_name}.${flattened_branch_name}"

    # Check if the target worktree directory already exists
    if [ -e "$worktree_dir" ]; then # Use -e to check for file or directory
        echo "Error: Target worktree directory '$worktree_dir' already exists." >&2
        return 1
    fi

    # --- Execution ---
    local branch_exists=false
    # Check if branch exists locally or remotely
    if git rev-parse --verify --quiet "refs/heads/$branch_name" > /dev/null 2>&1 || \
       git rev-parse --verify --quiet "refs/remotes/origin/$branch_name" > /dev/null 2>&1; then
        branch_exists=true
    fi

    echo "Creating worktree for branch '$branch_name' at '$worktree_dir'..."

    # Determine options for git worktree add
    local add_cmd_options=("${worktree_options[@]}") # Start with user-provided options

    if $branch_exists; then
        # Branch exists, just create worktree pointing to it
        # Use --force? Maybe not by default for 'new'. Let user pass it via options.
        if git worktree add "${add_cmd_options[@]}" "$worktree_dir" "$branch_name"; then
            echo "Worktree created for existing branch '$branch_name'."
        else
            echo "Error: Failed to create worktree for existing branch '$branch_name'." >&2
            # git worktree add might have created the dir but failed, attempt cleanup
            rmdir "$worktree_dir" 2>/dev/null || true
            return 1
        fi
    else
        # Branch does not exist, create it using -b
        # The new branch will be based on the current HEAD
        echo "Branch '$branch_name' does not exist. Creating new branch and worktree..."
        if git worktree add -b "$branch_name" "${add_cmd_options[@]}" "$worktree_dir"; then
             echo "New branch '$branch_name' and worktree created."
             # Optional: Push the new branch? Maybe not by default.
             # git -C "$worktree_dir" push --set-upstream origin "$branch_name"
        else
            echo "Error: Failed to create new branch '$branch_name' and worktree." >&2
            # git worktree add might have created the dir but failed, attempt cleanup
            rmdir "$worktree_dir" 2>/dev/null || true
            # Also attempt to clean up the potentially created branch if add failed midway
            git branch -D "$branch_name" 2>/dev/null || true
            return 1
        fi
    fi

    echo "git-express new complete for $repo_name.$flattened_branch_name"
}


# --- Main script logic ---
main() {
    if [ $# -eq 0 ]; then
        usage
    fi

    local command="$1"
    shift # Remove the command name from the arguments list

    case "$command" in
    clone)
        cmd_clone "$@"
        ;;
    new)
        cmd_new "$@"
        ;;
    --help | -h)
        usage
        ;;
    # Add other command cases here
    *)
        echo "Error: Unknown command '$command'"
        usage
        ;;
    esac
}

# Execute main function with all script arguments
main "$@"
